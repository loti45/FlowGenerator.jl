var documenterSearchIndex = {"docs":
[{"location":"internal/shortest_path_solver/#Shortest-Path-Solver","page":"Shortest Path Solver","title":"Shortest Path Solver","text":"","category":"section"},{"location":"internal/shortest_path_solver/","page":"Shortest Path Solver","title":"Shortest Path Solver","text":"Modules = [FlowGenerator.ShortestPathSolver]","category":"page"},{"location":"internal/shortest_path_solver/#FlowGenerator.ShortestPathSolver.Label","page":"Shortest Path Solver","title":"FlowGenerator.ShortestPathSolver.Label","text":"struct Label\n\nRepresents a label in the shortest path computation.\n\nFields\n\nvalue::Float64: The cost to reach the node this label is associated with.\nentering_arc::Arc: The arc through which this node was reached.\nmin_hops::Int: The minimum number of arcs required to generate this label.\n\n\n\n\n\n","category":"type"},{"location":"internal/shortest_path_solver/#FlowGenerator.ShortestPathSolver.ShortestPathGenerator","page":"Shortest Path Solver","title":"FlowGenerator.ShortestPathSolver.ShortestPathGenerator","text":"mutable struct ShortestPathGenerator\n\nA structure to accelerate the shortest path computation in networks by reusing a precomputed topologically sorted list of arcs and updating the solution object across calls.\n\nStoring the pre-sorted list of arcs is particularly beneficial when shortest path computations are frequently repeated with varying costs, as in the pricing solution of column generation for large-scale problems.\n\nFields\n\ntop_sorted_arc_list::Vector{Arc}: List of arcs already sorted by topological order.\nsource::Vertex: Source vertex for the shortest path computation.\nsink::Vertex: Sink (destination) vertex for the shortest path computation.\nsolution::ShortestPathSolution: Reusable object that holds the current shortest path solution. Reusing the solution object avoids inneficiencies due to memory allocation in huge problems.\n\n\n\n\n\n","category":"type"},{"location":"internal/shortest_path_solver/#FlowGenerator.ShortestPathSolver.ShortestPathSolution","page":"Shortest Path Solver","title":"FlowGenerator.ShortestPathSolver.ShortestPathSolution","text":"mutable struct ShortestPathSolution\n\nStores the state necessary for representing a set of solutions of a shortest path computation.\n\nFields\n\nforward_vertex_to_label::IndexedMap{Vertex,Label}: Mapping from vertices to labels for forward search from source to each vertex.\nbackward_vertex_to_label::IndexedMap{Vertex,Label}: Mapping from vertices to labels for backward search from sink to each vertex.\narc_to_cost::IndexedMap{Arc,Float64}: Mapping from arcs to their associated costs.\nis_hyper_graph::Bool: Flag indicating if the solution is for a hypergraph. In case this is true, no backward computation has been done.\n\nConstructor\n\nShortestPathSolution(network::Network): Initializes the solution with default labels and inf costs for a given network.\n\n\n\n\n\n","category":"type"},{"location":"internal/shortest_path_solver/#FlowGenerator.ShortestPathSolver.build_shortest_path_generator-Tuple{FlowGenerator.NetworkFlowModel.Network, Vertex, Vertex}","page":"Shortest Path Solver","title":"FlowGenerator.ShortestPathSolver.build_shortest_path_generator","text":"build_shortest_path_generator(network::Network, source::Vertex, sink::Vertex) -> ShortestPathGenerator\n\nConstructs a ShortestPathGenerator instance by creating a topologically sorted list of arcs from the network and initializing an empty shortest path solution.\n\n\n\n\n\n","category":"method"},{"location":"internal/shortest_path_solver/#FlowGenerator.ShortestPathSolver.generate_shortest_path-Tuple{FlowGenerator.NetworkFlowModel.Network, AbstractDict}","page":"Shortest Path Solver","title":"FlowGenerator.ShortestPathSolver.generate_shortest_path","text":"generate_shortest_path(network::Network, arc_to_cost::AbstractDict; solver::ShortestPathGenerator) -> ShortestPathSolution\n\nGenerates the shortest path solution for a given network using a specific ShortestPathGenerator.\n\nReturns\n\nShortestPathSolution: The shortest path solution found by the solver.\n\n\n\n\n\n","category":"method"},{"location":"internal/shortest_path_solver/#FlowGenerator.ShortestPathSolver.generate_shortest_path-Tuple{FlowGenerator.NetworkFlowModel.Network, Vertex, Vertex, AbstractDict}","page":"Shortest Path Solver","title":"FlowGenerator.ShortestPathSolver.generate_shortest_path","text":"generate_shortest_path(network::Network, source::Vertex, sink::Vertex, arc_to_cost::AbstractDict) -> ShortestPathSolution\n\nGenerates the shortest path solution for a given network from a source to a sink, using specific arc costs. Builds a ShortestPathGenerator internally.\n\nReturns\n\nShortestPathSolution: The shortest path solution found by the solver.\n\n\n\n\n\n","category":"method"},{"location":"internal/shortest_path_solver/#FlowGenerator.ShortestPathSolver.get_min_unit_flow_cost-Tuple{FlowGenerator.ShortestPathSolver.ShortestPathSolution, Arc}","page":"Shortest Path Solver","title":"FlowGenerator.ShortestPathSolver.get_min_unit_flow_cost","text":"get_min_unit_flow_cost(solution::ShortestPathSolution, arc::Arc) -> Float64\n\nCalculate the minimum flow cost in a path where the flow on arc is one unit. This function is not compatible with hyper-graphs.\n\nReturns\n\nFloat64: The minimum unit flow cost for the specified arc.\n\n\n\n\n\n","category":"method"},{"location":"internal/shortest_path_solver/#FlowGenerator.ShortestPathSolver.get_min_unit_flow_path-Tuple{FlowGenerator.ShortestPathSolver.ShortestPathSolution, Arc}","page":"Shortest Path Solver","title":"FlowGenerator.ShortestPathSolver.get_min_unit_flow_path","text":"get_min_unit_flow_path(solution::ShortestPathSolution, arc::Arc) -> Path\n\nObtain the path with the minimum unit flow cost for a given arc. This function does not support hyper-graphs and will throw an error if used in such context.\n\nReturns\n\nPath: The path corresponding to the minimum unit flow cost of the arc.\n\n\n\n\n\n","category":"method"},{"location":"internal/shortest_path_solver/#FlowGenerator.ShortestPathSolver.get_optimal_path-Tuple{FlowGenerator.ShortestPathSolver.ShortestPathSolution, Vertex}","page":"Shortest Path Solver","title":"FlowGenerator.ShortestPathSolver.get_optimal_path","text":"get_optimal_path(solution::ShortestPathSolution, sink::Vertex) -> Path\n\nRetrieve the optimal path from the source to the specified sink vertex using the shortest path solution data.\n\n\n\n\n\n","category":"method"},{"location":"internal/shortest_path_solver/#FlowGenerator.ShortestPathSolver.get_optimal_value_from_source-Tuple{FlowGenerator.ShortestPathSolver.ShortestPathSolution, Vertex}","page":"Shortest Path Solver","title":"FlowGenerator.ShortestPathSolver.get_optimal_value_from_source","text":"get_optimal_value_from_source(solution::ShortestPathSolution, vertex::Vertex) -> Float64\n\nReturn the optimal value (cost) of reaching a specified vertex from the source vertex using the shortest path solution data.\n\n\n\n\n\n","category":"method"},{"location":"internal/mip_model/#Mip-Model","page":"Mip Model","title":"Mip Model","text":"","category":"section"},{"location":"internal/mip_model/","page":"Mip Model","title":"Mip Model","text":"Modules = [FlowGenerator.MipModel]","category":"page"},{"location":"internal/mip_model/#FlowGenerator.MipModel.Column","page":"Mip Model","title":"FlowGenerator.MipModel.Column","text":"struct Column\n\nA struct for representing a column in the network flow MIP model. Each column is indexed by a (partial) hyper-tree and a commodity.\n\n\n\n\n\n","category":"type"},{"location":"internal/mip_model/#FlowGenerator.MipModel.CommodityFlowComponent","page":"Mip Model","title":"FlowGenerator.MipModel.CommodityFlowComponent","text":"struct CommodityFlowComponent\n\nA struct for representing the flow component of a specific commodity within a network flow model.\n\nContains a JuMP implementation of:\n\nthe arc and path flow variables and flow conservation constraints associated with the commodity;\nthe flow demand and capacity constraints of the commodity.\n\n\n\n\n\n","category":"type"},{"location":"internal/mip_model/#FlowGenerator.MipModel.NetworkFlowMipModel","page":"Mip Model","title":"FlowGenerator.MipModel.NetworkFlowMipModel","text":"struct NetworkFlowMipModel\n\nA struct for representing a mixed-integer programming (MIP) model for network flow problems.\n\nFields\n\nmip_model::JuMP.Model: The JuMP model object for the MIP.\nproblem::NetworkFlowModel.Problem: The network flow problem instance.\ncommodity_to_flow_data::Dict{Commodity,CommodityFlowComponent}: A dictionary mapping commodities to their respective flow components.\narc_to_capacity_constraint::Dict{NetworkFlowModel.Arc,JuMP.ConstraintRef}: A dictionary mapping arcs to their capacity constraints in the MIP model.\nside_constrs::Vector{JuMP.ConstraintRef}: A vector of additional side constraints added to the MIP model.\ndual_decimal_precision::Int: The precision used for the dual values retrieved from the JuMP model.\n\nThis struct is used to encapsulate all the components necessary to define and solve a MIP for a network flow problem, including the model itself, the problem data, constraints, and settings for numerical precision.\n\n\n\n\n\n","category":"type"},{"location":"internal/mip_model/#FlowGenerator.MipModel.NetworkFlowMipModel-Tuple{FlowGenerator.NetworkFlowModel.Problem, FlowGenerator.Parameters.MipSolverParams}","page":"Mip Model","title":"FlowGenerator.MipModel.NetworkFlowMipModel","text":"NetworkFlowMipModel(\n    problem::NetworkFlowModel.Problem, \n    params::MipSolverParams\n) -> NetworkFlowMipModel\n\nCreate a new mixed-integer programming (MIP) model for a network flow problem.\n\nReturns\n\nNetworkFlowMipModel: A NetworkFlowMipModel instance with initialized MIP model, constraints, and variables.\n\n\n\n\n\n","category":"method"},{"location":"internal/mip_model/#FlowGenerator.AbstractSolver.solve-Tuple{FlowGenerator.NetworkFlowModel.Problem, FlowGenerator.Parameters.MipSolverParams}","page":"Mip Model","title":"FlowGenerator.AbstractSolver.solve","text":"AbstractSolver.solve(\n    problem::NetworkFlowModel.Problem, \n    params::MipSolverParams;\n    time_limit::Float64 = Inf\n) -> PrimalSolution\n\nSolve a network flow problem directly as a mixed-integer programming (MIP) model.  Keyword parameter time_limit is given in seconds.\n\nReturns\n\nA PrimalSolution object representing the optimal solution.\n\n\n\n\n\n","category":"method"},{"location":"internal/mip_model/#FlowGenerator.MipModel.add_column!-Tuple{FlowGenerator.MipModel.CommodityFlowComponent, FlowGenerator.MipModel.Column}","page":"Mip Model","title":"FlowGenerator.MipModel.add_column!","text":"add_column!(flow_component::CommodityFlowComponent, column::Column)\n\nAdd a column to the CommodityFlowComponent if it does not already exist.\n\nReturns a JuMP variable reference for the newly added column. Returns nothing if the variable already exists.\n\nThis function creates a variable, assigns it a cost coefficient in the objective function, and updates flow conservation and commodity flow constraints to include this variable.\n\n\n\n\n\n","category":"method"},{"location":"internal/mip_model/#FlowGenerator.MipModel.add_column!-Tuple{FlowGenerator.MipModel.NetworkFlowMipModel, FlowGenerator.MipModel.Column}","page":"Mip Model","title":"FlowGenerator.MipModel.add_column!","text":"add_column!(\n    model::NetworkFlowMipModel,\n    column::Column,\n) -> Bool\n\nAdd a column/variable to the MIP model representing the flow of a commodity along a specific hyper-tree. The hyper-tree can represent a single hyper-arc, a partial hyper-tree, or a complete hyper-tree from the source to the sink of the commodity. The variable is added only if the hyper-tree is in the network of the problem and an equivalent variable does not already exist.\n\nReturns\n\ntrue if the variable was successfully added, otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"internal/mip_model/#FlowGenerator.MipModel.delete_column_var!-Tuple{FlowGenerator.MipModel.CommodityFlowComponent, FlowGenerator.MipModel.Column}","page":"Mip Model","title":"FlowGenerator.MipModel.delete_column_var!","text":"delete_column!(flow_component::CommodityFlowComponent, column::Column)\n\nDelete a column from the CommodityFlowComponent by setting the upper bound to 0 and removing it from assocaited data structures.\n\nNote: setting the variable upper bound to 0 is more efficient than deleting the variable.\n\n\n\n\n\n","category":"method"},{"location":"internal/mip_model/#FlowGenerator.MipModel.get_arc_flow_solution-Tuple{FlowGenerator.MipModel.CommodityFlowComponent}","page":"Mip Model","title":"FlowGenerator.MipModel.get_arc_flow_solution","text":"get_arc_flow_solution(flow_component::CommodityFlowComponent) -> ArcFlowSolution\n\nRetrieve the flow solution for all arcs within the CommodityFlowComponent.\n\nThis function calculates the flow solution for each arc by rounding the value of the associated variable and aggregating the flow values from the path variables as well.\n\n\n\n\n\n","category":"method"},{"location":"internal/mip_model/#FlowGenerator.MipModel.get_columns-Tuple{FlowGenerator.MipModel.CommodityFlowComponent}","page":"Mip Model","title":"FlowGenerator.MipModel.get_columns","text":"get_columns(flow_component::CommodityFlowComponent)\n\nReturn all columns that have been created in the CommodityFlowComponent.\n\n\n\n\n\n","category":"method"},{"location":"internal/mip_model/#FlowGenerator.MipModel.get_columns-Tuple{FlowGenerator.MipModel.NetworkFlowMipModel, Commodity}","page":"Mip Model","title":"FlowGenerator.MipModel.get_columns","text":"get_columns(mip_model::NetworkFlowMipModel, commodity::Commodity) -> Vector{Column}\n\nGet all columns associated with the given commodity.\n\n\n\n\n\n","category":"method"},{"location":"internal/mip_model/#FlowGenerator.MipModel.get_dual_solution-Tuple{FlowGenerator.MipModel.NetworkFlowMipModel}","page":"Mip Model","title":"FlowGenerator.MipModel.get_dual_solution","text":"get_dual_solution(model::NetworkFlowMipModel) -> DualSolution\n\nRetrieve the dual solution from a solved NetworkFlowMipModel. Only works if the model is an LP model (all variables are linear).\n\n\n\n\n\n","category":"method"},{"location":"internal/mip_model/#FlowGenerator.MipModel.get_flow_conservation_constraint!-Tuple{FlowGenerator.MipModel.CommodityFlowComponent, Vertex}","page":"Mip Model","title":"FlowGenerator.MipModel.get_flow_conservation_constraint!","text":"get_flow_conservation_constraint!(\n    flow_component::CommodityFlowComponent, vertex::Vertex\n)\n\nRetrieve or create a flow conservation constraint for a specified vertex within the CommodityFlowComponent.\n\nReturns\n\nconstraint::JuMP.ConstraintRef: The JuMP constraint reference for the flow conservation at the specified vertex.\n\nThis function ensures that there is a flow conservation constraint for each vertex. If the constraint does not exist, it is created with a default expression of 0.0 == 0.0.\n\n\n\n\n\n","category":"method"},{"location":"internal/mip_model/#FlowGenerator.MipModel.get_primal_solution-Tuple{FlowGenerator.MipModel.NetworkFlowMipModel}","page":"Mip Model","title":"FlowGenerator.MipModel.get_primal_solution","text":"get_primal_solution(model::NetworkFlowMipModel) -> PrimalSolution\n\nRetrieve the primal solution from a solved MIP model\n\n\n\n\n\n","category":"method"},{"location":"internal/mip_model/#FlowGenerator.MipModel.optimize!-Tuple{FlowGenerator.MipModel.NetworkFlowMipModel}","page":"Mip Model","title":"FlowGenerator.MipModel.optimize!","text":"optimize!(model::NetworkFlowMipModel; time_limit::Float64 = Inf)\n\nOptimize the MIP model associated with a network flow problem by calling JuMP.optimize!(). time_limit is given in seconds.\n\nReturns\n\nnothing.\n\n\n\n\n\n","category":"method"},{"location":"internal/data_containers/#Data-Containers","page":"Data Containers","title":"Data Containers","text":"","category":"section"},{"location":"internal/data_containers/","page":"Data Containers","title":"Data Containers","text":"Modules = [FlowGenerator.DataContainers]","category":"page"},{"location":"internal/data_containers/#FlowGenerator.DataContainers.IndexedMap","page":"Data Containers","title":"FlowGenerator.DataContainers.IndexedMap","text":"IndexedMap{K,V} is a (partial) implementation of AbstractDict{K,V}. It provides fast index-based access and allows a default value to be specified. It supports efficient addition and removal of key-value pairs.\n\n\n\n\n\n","category":"type"},{"location":"internal/data_containers/#FlowGenerator.DataContainers.LinkedListMap","page":"Data Containers","title":"FlowGenerator.DataContainers.LinkedListMap","text":"struct LinkedListMap{T}\n\nA data structure that implements a map of integers to linked lists, with each list containing elements of type T. It is designed to manage multiple linked lists efficiently by using a shared array of nodes (nodes)  to store all elements of all lists, which improves memory allocation efficiency.\n\nFields\n\nlist_head_index::Vector{Int}: An array where each element is an integer representing the index of the first node  of a linked list in the nodes array. If the value is -1, it indicates that the linked list is empty.\nnodes::Vector{LinkedListNode{T}}: An array of LinkedListNode{T} that stores the nodes of all linked lists.  Each node contains a value of type T and an integer pointing to the next node in its list.\n\nConstructor\n\nLinkedListMap{T}(num_lists::Int) where {T}\n\nCreates an instance of LinkedListMap with a specified number of lists (given by num_lists). Each list is initialized as empty.\n\nUsage\n\nTo add a value to a specific list, use add_value!(list_map::LinkedListMap{T}, list_index::Int, value::T).\nTo iterate over the elements of a list, obtain an iterator using get_list_iter(list_map::LinkedListMap{T}, list_index::Int).\nTo access a list iterator directly, use the indexing syntax with list_map[index].\n\nExample\n\nlist_map = LinkedListMap{Int}(3)  # Create a map for 3 linked lists of integers\nadd_value!(list_map, 1, 10)       # Add the value 10 to the first list\nadd_value!(list_map, 1, 20)       # Add the value 20 to the first list\nadd_value!(list_map, 2, 30)       # Add the value 30 to the second list\nfor value in list_map[1]          # Iterate over the first list\n    println(value)\nend\n\nThis will output 10 and 20.\n\nNote that this struct does not provide direct methods to remove nodes or to insert nodes at arbitrary positions. All nodes are added at the end (tail) of their respective lists.\n\n\n\n\n\n","category":"type"},{"location":"examples/bin_packing_problem/#Bin-Packing-Problem","page":"Bin Packing Problem","title":"Bin Packing Problem","text":"","category":"section"},{"location":"examples/bin_packing_problem/","page":"Bin Packing Problem","title":"Bin Packing Problem","text":"In the (one-dimensional) bin packing problem (BPP), we are given an unlimited number of bins with identical capacity W, and a set I of items. Each item i in I is associated with a weight w_i. The objective of the problem is to pack all items into the minimum number of bins, while respecting the weight capacity of bins.","category":"page"},{"location":"examples/bin_packing_problem/","page":"Bin Packing Problem","title":"Bin Packing Problem","text":"Here, we consider the classical arc-flow model for the BPP. For details on the model, we refer to the first paper that addressed it in practice:","category":"page"},{"location":"examples/bin_packing_problem/","page":"Bin Packing Problem","title":"Bin Packing Problem","text":"Valério de Carvalho, J. M. Exact solution of bin‐packing problems using column generation and branch‐and‐bound. Annals of Operations Research. 86(0), 629-659 (1999).","category":"page"},{"location":"examples/bin_packing_problem/","page":"Bin Packing Problem","title":"Bin Packing Problem","text":"The model has a vertex for each possible partial weight (which we call position) in a bin. There are two types of arcs, item arcs and loss arcs.","category":"page"},{"location":"examples/bin_packing_problem/","page":"Bin Packing Problem","title":"Bin Packing Problem","text":"Item arcs represent the placement of an arc in a position of an arbitrary bin. In particular, an item i has arcs like (u u + w_i), where u in 0ldotsW is a vertex representing a position in a bin.\nLoss arcs represent unused space that accumulate at the end of a bin.","category":"page"},{"location":"examples/bin_packing_problem/","page":"Bin Packing Problem","title":"Bin Packing Problem","text":"Each complete path in this model represents a feasible packing of items in a single bin. The objective of minimizing the number of used bins is translated to minimizing the total flow over the network. This objective can be modelled in multiple ways. Here we choose to model it by setting a uniform cost of 1 to all arcs leaving the source. This effectively minimizes the number of bins since each unit of flow leaving the source represent the use of a bin.","category":"page"},{"location":"examples/bin_packing_problem/","page":"Bin Packing Problem","title":"Bin Packing Problem","text":"The size of the graph depends on the sets of feasible positions for each item. There are many studies focusing on generating smaller sets of positions without losing optimality. For simplicity, we consider the seminal approach by Valério de Carvalho, which is based on the principle that items can be assumed to be left-aligned inside of a bin.","category":"page"},{"location":"examples/bin_packing_problem/","page":"Bin Packing Problem","title":"Bin Packing Problem","text":"The following illustrates how to use FlowGenerator to construct and solve the classical arc-flow model for the BPP.","category":"page"},{"location":"examples/bin_packing_problem/","page":"Bin Packing Problem","title":"Bin Packing Problem","text":"using FlowGenerator\nusing HiGHS\n\nfunction solve_bin_packing(capacity::Int, weights::Vector{Int})\n    num_items = length(weights)\n\n    # builder for the network flow problem\n    builder = new_problem_builder()\n\n    # mapping of positions in a bin to vertices\n    position_to_vertex = Dict{Int,Vertex}()\n    position_to_vertex[0] = new_vertex!(builder)\n\n    # used to create constraints and to convert the network-based solution to a bin packing solution\n    arc_to_item = Dict{Arc,Int}()\n\n    # item arcs\n    for i in 1:num_items\n        # collect is used to ensure we iterate only over vertices created in previous iterations\n        current_positions = collect(keys(position_to_vertex))\n        for p in current_positions\n            if p + weights[i] <= capacity\n                tail = position_to_vertex[p]\n                head = get!(position_to_vertex, p + weights[i], new_vertex!(builder))\n                arc = new_arc!(builder, tail, head; var_type = INTEGER)\n                arc_to_item[arc] = i\n                if p == 0\n                    set_cost!(builder, arc, 1.0)\n                end\n            end\n        end\n    end\n\n    # loss arcs\n    sink = get!(position_to_vertex, capacity, new_vertex!(builder))\n    for (p, vertex) in position_to_vertex\n        if p < capacity\n            new_arc!(builder, vertex, sink; var_type = INTEGER)\n        end\n    end\n\n    # create a demand constraint for each item\n    item_to_demand_constraint = Dict(\n        i => new_constraint!(builder; lb = 1.0, ub = 1.0) for i in 1:num_items\n    )\n\n    # populate demand constraint coefficients\n    for (arc, item) in arc_to_item\n        set_constraint_coefficient!(builder, item_to_demand_constraint[item], arc, 1.0)\n    end\n\n    # new commodity from source to sink\n    flow_capacity = num_items # enough to support any feasible solution\n    commodity = new_commodity!(\n        builder, position_to_vertex[0], sink, 0.0, flow_capacity\n    )\n\n    # optimizing the problem\n    problem = get_problem(builder)\n    solution = optimize!(problem, HiGHS.Optimizer)\n\n    # converting network-flow solution to bin packing solution\n    bin_solution_list = Vector{Vector{Int}}()\n    for (path, flow) in get_path_to_flow_map(problem, solution, commodity)\n        bin_solution = get_bin_solution(arc_to_item, path)\n        num_bins = floor(Int, flow + 0.5) # rounding to deal with floating-point precision\n        append!(bin_solution_list, fill(bin_solution, num_bins))\n    end\n\n    return bin_solution_list\nend\n\nfunction get_bin_solution(arc_to_item, path)\n    bin_pattern = Vector{Int}()\n    for arc in get_arcs(path)\n        if haskey(arc_to_item, arc)\n            item = arc_to_item[arc]\n            push!(bin_pattern, item)\n        end\n    end\n    return bin_pattern\nend\n\ncapacity = 100\nweights = [4, 6, 7, 24, 26, 32, 64, 68, 69]\n\nsolve_bin_packing(capacity, weights)","category":"page"},{"location":"internal/network_flow_model/#Network-Flow-Model","page":"Network Flow Model","title":"Network Flow Model","text":"","category":"section"},{"location":"internal/network_flow_model/","page":"Network Flow Model","title":"Network Flow Model","text":"Modules = [FlowGenerator.NetworkFlowModel]","category":"page"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.ArcFlowSolution","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.ArcFlowSolution","text":"struct ArcFlowSolution\n\nA solution object for network flow problems that maps arcs to their flows.\n\nFields\n\narc_to_flow_map::Dict{Arc,Float64}: A dictionary that maps Arc objects to Float64 flow values.\nsource::Vertex: The source of the flow.\nsink::Vertex: The destination of of the flow.\n\nConstructor\n\nArcFlowSolution(c::Commodity)\n\nConstructs an ArcFlowSolution with an empty flow map and specified source and sink vertices based on a given Commodity.\n\n\n\n\n\n","category":"type"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.Problem","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.Problem","text":"struct Problem\n\nEncapsulates the data needed to define and solve a network flow optimization problem.\n\nFields\n\nnetwork::Network: Represents the flow network with nodes and arcs.\nobjective_function::ObjectiveFunction: A linear function defining the objective of the optimization.\narc_to_capacity_map::IndexedMap{Arc,Float64}: A mapping from arcs to their capacities.\narc_to_var_type_map::IndexedMap{Arc,VarType}: A mapping from arcs to their variable types, either INTEGER or CONTINUOUS.\nconstraints::Vector{Constraint}: A vector of generic linear side-constraints.\ncommodities::Vector{Commodity}: A vector of commodities to be sent through the network.\narc_to_side_constr_coeffs::LinkedListMap{Tuple{Int,Float64}}: An auxiliary mapping for side constraints coefficients for enhanced solution computation. To be computed by constructors.\n\nConstructors\n\nProblem(network, arc_to_cost, arc_to_capacity, arc_to_var_type, constraints, commodities): Constructs a Problem instance given network parameters and functions to define arc costs, capacities, variable types, constraints, and commodities.\nProblem(problem, network): Constructs a new Problem instance based on an existing problem but with a different network structure.\n\nMethods\n\nget_network(problem): Returns the network of the problem.\nget_arcs(problem): Returns the arcs of the problem's network.\nget_vertices(problem): Returns the vertices of the problem's network.\nget_constraints(problem): Returns the constraints of the problem.\nget_commodities(problem): Returns the commodities of the problem.\nget_cost(problem, arc): Returns the cost of an arc.\nget_cost(problem, path): Returns the cost of a path.\nget_capacity(problem, arc): Returns the capacity of an arc.\nget_var_type(problem, arc): Returns the variable type of an arc.\nget_constr_coeff_list(problem, arc): Returns the list of constraint coefficients for an arc.\npush_constraint!(problem, constraint): Adds a new constraint to the problem.\npop_constraint!(problem): Removes the most recently added constraint from the problem.\n_get_arc_to_side_constr_coeffs(arcs, constraints): Internal function to initialize the mapping of arcs to their side constraint coefficients.\nis_problem_integer(problem): Returns true if the objective is integer for any feasible solution satisfying integrality constraints.\nfilter_arcs(problem, pred): Returns a new instance of Problem where only the arcs satisfying the predicate pred are kept.\n\n\n\n\n\n","category":"type"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.VarType","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.VarType","text":"@enum VarType\n\nAn Enum type representing different variable types for arcs in a flow network problem.\n\nValues\n\nINTEGER: Indicates that the variable is restricted to integer values.\nCONTINUOUS: Indicates that the variable can take any continuous real value.\n\n\n\n\n\n","category":"type"},{"location":"internal/network_flow_model/#Base.in-Tuple{Arc, FlowGenerator.NetworkFlowModel.Network}","page":"Network Flow Model","title":"Base.in","text":"Base.in(arc::Arc, network::Network)\n\nCheck if an arc is in the network.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#Base.in-Tuple{FlowGenerator.NetworkFlowModel.HyperTree, FlowGenerator.NetworkFlowModel.Network}","page":"Network Flow Model","title":"Base.in","text":"Base.in(hyper_tree::HyperTree, network::Network)\n\nCheck if a hyper-tree is in the network.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#Base.in-Tuple{FlowGenerator.NetworkFlowModel.Path, FlowGenerator.NetworkFlowModel.Network}","page":"Network Flow Model","title":"Base.in","text":"Base.in(path::Path, network::Network)\n\nCheck if a path is in the network.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.convert_to_path_flow_solution-Tuple{FlowGenerator.NetworkFlowModel.Network, FlowGenerator.NetworkFlowModel.ArcFlowSolution}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.convert_to_path_flow_solution","text":"convert_to_path_flow_solution(network::Network, arc_flow_solution::ArcFlowSolution)\n\nConvert an ArcFlowSolution to a PathFlowSolution using a flow decomposition algorithm.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.fill_arc_to_reduced_cost_map!-Tuple{AbstractDict{Arc, Float64}, FlowGenerator.NetworkFlowModel.Problem, FlowGenerator.NetworkFlowModel.DualSolution}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.fill_arc_to_reduced_cost_map!","text":"fill_arc_to_reduced_cost_map!(arc_to_reduced_cost_map::AbstractDict{Arc,Float64}, problem::Problem, dual_solution::DualSolution)\n\nFill the arc_to_reduced_cost_map with the reduced cost of each arc.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.filter_arcs-Tuple{FlowGenerator.NetworkFlowModel.Network, Function}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.filter_arcs","text":"filter_arcs(network::Network, predicate::Function)\n\nReturn a copy of the network with only the arcs that satisfy a given predicate.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.filter_arcs-Tuple{FlowGenerator.NetworkFlowModel.Problem, Function}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.filter_arcs","text":"filter_arcs(problem::Problem, predicate::Function) -> Problem\n\nCreates a new Problem instance by filtering out arcs in the original problem's network that do not satisfy a given predicate function.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.find_path-Tuple{FlowGenerator.NetworkFlowModel.Network, Vertex, Vertex, Function}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.find_path","text":"find_path(network::Network, source::Vertex, sink::Vertex, arc_to_flow::Function)\n\nReturns a path from source to sink in a network with positive flow capacity. If no such path exists, returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.get_arc_flow_solution-Tuple{FlowGenerator.NetworkFlowModel.PrimalSolution, Commodity}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.get_arc_flow_solution","text":"get_arc_flow_solution(primal_solution::PrimalSolution, commodity::Commodity)\n\nReturn the arc flow solution for a specific commodity in the given primal solution.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.get_arc_reduced_cost-Tuple{FlowGenerator.NetworkFlowModel.Problem, FlowGenerator.NetworkFlowModel.DualSolution, Arc}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.get_arc_reduced_cost","text":"get_arc_reduced_cost(problem::Problem, dual_solution::DualSolution, arc::Arc; capacity_dual = get_arc_capacity_dual(problem, dual_solution, arc))\n\nGet the reduced cost of an arc based on the dual solution. The reduced cost is computed based on side constraint and capacity dual values, but not on commodity and flow conservation dual values.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.get_arc_to_flow_map-Tuple{FlowGenerator.NetworkFlowModel.PrimalSolution, Commodity}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.get_arc_to_flow_map","text":"get_arc_to_flow_map(primal_solution::PrimalSolution, commodity::Commodity)\n\nReturn the arc to flow map for a specific commodity in the given primal solution.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.get_arcs-Tuple{FlowGenerator.NetworkFlowModel.Network}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.get_arcs","text":"get_arcs(network::Network)\n\nReturn the list of arcs in the network.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.get_commodity_dual-Tuple{FlowGenerator.NetworkFlowModel.DualSolution, Commodity}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.get_commodity_dual","text":"get_commodity_dual(dual_solution::DualSolution, commodity::Commodity)\n\nGet the dual value associated with a commodity.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.get_flow_conservation_balance-Tuple{Dict{Arc, Float64}}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.get_flow_conservation_balance","text":"get_flow_conservation_balance(arc_to_flow_map::Dict{Arc,Float64})\n\nCalculates the flow conservation balance for each vertex based on a given arc_to_flow_map.\n\nReturns\n\nA dictionary mapping each vertex to its flow conservation balance.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.get_flow_conservation_balance-Tuple{FlowGenerator.NetworkFlowModel.ArcFlowSolution}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.get_flow_conservation_balance","text":"get_flow_conservation_balance(sol::ArcFlowSolution)\n\nCalculates the flow conservation balance for each vertex in an ArcFlowSolution.\n\nReturns\n\nA dictionary mapping each vertex to its flow conservation balance.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.get_flow_cost-Tuple{FlowGenerator.NetworkFlowModel.Problem, Dict{Arc, Float64}}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.get_flow_cost","text":"get_flow_cost(problem::Problem, arc_to_flow_map::Dict{Arc,Float64})\n\nReturns the total flow cost for a given problem.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.get_incoming_flow-Tuple{FlowGenerator.NetworkFlowModel.ArcFlowSolution, Vertex}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.get_incoming_flow","text":"get_incoming_flow(arc_flow_solution::ArcFlowSolution, vertex::Vertex)\n\nReturns the total incoming flow to a specified vertex in an ArcFlowSolution.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.get_obj_val-Tuple{FlowGenerator.NetworkFlowModel.Problem, FlowGenerator.NetworkFlowModel.DualSolution}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.get_obj_val","text":"get_obj_val(problem::Problem, dual_solution::DualSolution)\n\nReturn objective value of dual solution. Dual feasibility is not taken into account.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.get_obj_val-Tuple{FlowGenerator.NetworkFlowModel.Problem, FlowGenerator.NetworkFlowModel.PrimalSolution}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.get_obj_val","text":"get_obj_val(problem::Problem, solution::PrimalSolution)\n\nCalculate the objective value of a primal solution for a given problem. The objective consists of: flow cost and constraint/commodity violation penalty costs\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.get_outgoing_arcs-Tuple{FlowGenerator.NetworkFlowModel.Network, Vertex}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.get_outgoing_arcs","text":"getoutgoingarcs(n::Network, v::Vertex)\n\nReturn the list of outgoing arcs from a given vertex in the network.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.get_path_flow-Tuple{FlowGenerator.NetworkFlowModel.PathFlowSolution, FlowGenerator.NetworkFlowModel.Path}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.get_path_flow","text":"get_path_flow(sol::PathFlowSolution, path::Path)\n\nGet the flow associated with a specific path in a PathFlowSolution. If the path is not present in the solution, returns 0.0.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.get_path_to_flow_map-Tuple{FlowGenerator.NetworkFlowModel.PathFlowSolution}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.get_path_to_flow_map","text":"get_path_to_flow_map(sol::PathFlowSolution)\n\nGet the path to flow map in a PathFlowSolution.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.get_side_constraint_dual-Tuple{FlowGenerator.NetworkFlowModel.DualSolution, FlowGenerator.NetworkFlowModel.Constraint}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.get_side_constraint_dual","text":"get_side_constraint_dual(dual_solution::DualSolution, constraint::Constraint)\n\nGet the dual value associated with a side constraint.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.get_vertices-Tuple{Arc}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.get_vertices","text":"get_vertices(arc::Arc)\n\nReturn all vertices in the arc.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.get_vertices-Tuple{FlowGenerator.NetworkFlowModel.Network}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.get_vertices","text":"get_vertices(network::Network)\n\nReturn the list of vertices in the network.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.get_vertices-Tuple{Vector{Arc}}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.get_vertices","text":"get_vertices(arcs::Vector{Arc})\n\nReturn all vertices in the list of arcs.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.is_flow_conservation_feasible-Tuple{FlowGenerator.NetworkFlowModel.ArcFlowSolution}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.is_flow_conservation_feasible","text":"is_flow_conservation_feasible(sol::ArcFlowSolution)\n\nChecks if flow conservation is feasible for an ArcFlowSolution.\n\nFlow conservation is feasible if the flow conservation balance of all intermediate nodes is zero\n\nReturns\n\ntrue if flow conservation is feasible, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.is_hyper_graph-Tuple{FlowGenerator.NetworkFlowModel.Network}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.is_hyper_graph","text":"ishypergraph(n::Network)\n\nCheck if the network is a hypergraph.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.is_integrality_feasible-Tuple{FlowGenerator.NetworkFlowModel.Problem, FlowGenerator.NetworkFlowModel.ArcFlowSolution}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.is_integrality_feasible","text":"is_integrality_feasible(problem::Problem, solution::ArcFlowSolution)\n\nChecks if flow integrality of an ArcFlowSolution is satisfied for a given Problem.\n\nReturns\n\ntrue if the solution is integrality feasible, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.is_integrality_feasible-Tuple{FlowGenerator.NetworkFlowModel.Problem, FlowGenerator.NetworkFlowModel.PrimalSolution}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.is_integrality_feasible","text":"is_integrality_feasible(problem::Problem, solution::PrimalSolution)\n\nChecks if flow integrality of a PrimalSolution is satisfied for a given Problem.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.is_problem_integer-Tuple{FlowGenerator.NetworkFlowModel.Problem}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.is_problem_integer","text":"is_problem_integer(problem::Problem) -> Bool\n\nDetermines whether the problem has an integer objective function for any feasible solution that meets all integrality constraints on the variables.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.new_network-Tuple{Vector{Vertex}, Vector{Arc}}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.new_network","text":"new_network(vertices::Vector{Vertex}, arcs::Vector{Arc})\n\nCreate a new Network object with the given vertices and arcs.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.propagate_costs-Tuple{FlowGenerator.NetworkFlowModel.HyperTree}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.propagate_costs","text":"function propagate_costs(hyper_tree::HyperTree; arc_to_cost::Function, tail_to_cost::Function)\n\nPropagate costs along the hyper tree from tails towards the head.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_model/#FlowGenerator.NetworkFlowModel.topological_sort-Tuple{FlowGenerator.NetworkFlowModel.Network, Vector{Vertex}}","page":"Network Flow Model","title":"FlowGenerator.NetworkFlowModel.topological_sort","text":"topological_sort(network::Network, sources::Vector{Vertex})\n\nPerform a topological sort on the network starting from the given source vertices.\n\n\n\n\n\n","category":"method"},{"location":"internal/network_flow_solver/#Network-Flow-Solver","page":"Network Flow Solver","title":"Network Flow Solver","text":"","category":"section"},{"location":"internal/network_flow_solver/","page":"Network Flow Solver","title":"Network Flow Solver","text":"Modules = [FlowGenerator.NetworkFlowSolver]","category":"page"},{"location":"internal/network_flow_solver/#FlowGenerator.AbstractSolver.solve-Tuple{FlowGenerator.NetworkFlowModel.Problem, FlowGenerator.Parameters.NetworkFlowSolverParams}","page":"Network Flow Solver","title":"FlowGenerator.AbstractSolver.solve","text":"AbstractSolver.solve(\n    problem::NetworkFlowModel.Problem,\n    params::NetworkFlowSolverParams;\n    initial_paths::Vector{Tuple{Commodity,Path}} = Tuple{Commodity,Path}[],\n    initial_columns = MipModel.Column[\n        MipModel.Column(problem, path, commodity) for (commodity, path) in initial_paths\n    ],\n    obj_cutoff::Number = params.obj_cutoff,\n    max_num_branching_levels::Int,\n) -> NetworkFlowModel.PrimalSolution\n\nSolves a network flow model problem by column generation, branching, and reduced-cost variable-fixing. The function applies unbalanced branching to favor finding good quality primal solutions, up to a specified maximum number of branching levels.\n\n\n\n\n\n","category":"method"},{"location":"internal/column_generation/#Column-Generation","page":"Column Generation","title":"Column Generation","text":"","category":"section"},{"location":"internal/column_generation/","page":"Column Generation","title":"Column Generation","text":"warning: Warning\nThe Column Generation documentation is under construction","category":"page"},{"location":"internal/column_generation/","page":"Column Generation","title":"Column Generation","text":"Modules = [FlowGenerator.ColumnGeneration]","category":"page"},{"location":"internal/column_generation/#FlowGenerator.ColumnGeneration.add_column!-Tuple{FlowGenerator.ColumnGeneration.ColumnGenerationOptimizer, FlowGenerator.MipModel.Column}","page":"Column Generation","title":"FlowGenerator.ColumnGeneration.add_column!","text":"add_column!(cg::ColumnGenerationOptimizer, column::Column)\n\nAdd a column to the the underlying RMP if it does not already exist. Return true if the column was added, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Public interface","title":"Public interface","text":"CurrentModule = FlowGenerator","category":"page"},{"location":"#Flow-Generator","page":"Public interface","title":"Flow Generator","text":"","category":"section"},{"location":"","page":"Public interface","title":"Public interface","text":"Public Interface of FlowGenerator.","category":"page"},{"location":"","page":"Public interface","title":"Public interface","text":"Modules = [FlowGenerator]","category":"page"},{"location":"#FlowGenerator.NetworkFlowProblemBuilder","page":"Public interface","title":"FlowGenerator.NetworkFlowProblemBuilder","text":"NetworkFlowProblemBuilder\n\nThis structure is used to build network flow problems. The builder allows the user to define a network with vertices, arcs, and commodities, and side constraints.  \n\nUsage\n\nCreating a new instance of the builder:\n\nbuilder = new_problem_builder()\n\nAdding elements to the problem:\n\nvertex = new_vertex!(builder)\narc = new_arc!(builder, vertex1, vertex2)\ncommodity = new_commodity!(builder, source_vertex, sink_vertex, demand, capacity)\n\nSetting arc properties:\n\nset_cost!(builder, arc, cost)\nset_capacity!(builder, arc, capacity)\nset_var_type!(builder, arc, var_type)\n\nDefining a side-constraint:\n\nconstraint = new_constraint!(builder, lb, ub)\nset_constraint_coefficient!(builder, constraint, arc, coefficient)\n\nOnce the problem is fully constructed, it can be converted into a NetworkFlowModel.Problem and optimized using an appropriate MIP solver:\n\nproblem = get_problem(builder)\nsolution = optimize!(problem, mip_solver)\n\nExamples\n\nbuilder = new_problem_builder()\nv1 = new_vertex!(builder)\nv2 = new_vertex!(builder)\nv3 = new_vertex!(builder)\narc1 = new_arc!(builder, v1, v2; cost=5.0, capacity=10.0, var_type=CONTINUOUS)\narc2 = new_arc!(builder, v1, v2; var_type=INTEGER)\nset_cost!(builder, arc2, 7.0)\ncommodity = new_commodity!(builder, v1, v3, 2.0, 10.0)\nconstraint = new_constraint!(builder, lb=9.0, ub=10.0\nset_constraint_coefficient!(builder, constraint, arc1, 1.0)\nset_constraint_coefficient!(builder, constraint, arc2, 2.0)\nproblem = get_problem(builder)\nmip_solver = HiGHS.Optimizer\nsolution = optimize!(problem, mip_solver)\n\n\n\n\n\n","category":"type"},{"location":"#FlowGenerator.filter_arcs_by_reduced_cost-Tuple{FlowGenerator.NetworkFlowModel.Problem, Any, Number}","page":"Public interface","title":"FlowGenerator.filter_arcs_by_reduced_cost","text":"filter_arcs_by_reduced_cost(problem::Problem, mip_solver, cutoff::Number)\n\nRemove arcs that are not good candidates to find a solution better than cutoff.\n\nReturns the filtered problem.\n\n\n\n\n\n","category":"method"},{"location":"#FlowGenerator.get_arcs-Tuple{FlowGenerator.NetworkFlowModel.Network}","page":"Public interface","title":"FlowGenerator.get_arcs","text":"get_arcs(network::Network)\n\nReturn the arcs in a network.\n\n\n\n\n\n","category":"method"},{"location":"#FlowGenerator.get_arcs-Tuple{FlowGenerator.NetworkFlowModel.Path}","page":"Public interface","title":"FlowGenerator.get_arcs","text":"get_arcs(path::Path)\n\nReturn the arcs in a path. The arcs do not follow any particular order.\n\n\n\n\n\n","category":"method"},{"location":"#FlowGenerator.get_flow-Tuple{FlowGenerator.NetworkFlowModel.PrimalSolution, Arc}","page":"Public interface","title":"FlowGenerator.get_flow","text":"get_flow(solution::NetworkFlowModel.PrimalSolution, arc::Arc)\n\nReturn the total flow for a specific arc in the given solution.\n\n\n\n\n\n","category":"method"},{"location":"#FlowGenerator.get_flow-Tuple{FlowGenerator.NetworkFlowModel.PrimalSolution, Commodity, Arc}","page":"Public interface","title":"FlowGenerator.get_flow","text":"get_flow(solution::NetworkFlowModel.PrimalSolution, commodity::Commodity, arc::Arc)\n\nReturn the flow for a specific commodity and arc in the given solution.\n\n\n\n\n\n","category":"method"},{"location":"#FlowGenerator.get_obj_val-Tuple{FlowGenerator.NetworkFlowModel.Problem, FlowGenerator.NetworkFlowModel.PrimalSolution}","page":"Public interface","title":"FlowGenerator.get_obj_val","text":"get_obj_val(problem::NetworkFlowModel.Problem, solution::NetworkFlowModel.PrimalSolution)\n\nReturn the objective value for the given problem and solution.\n\n\n\n\n\n","category":"method"},{"location":"#FlowGenerator.get_path_to_flow_map-Tuple{FlowGenerator.NetworkFlowModel.Problem, FlowGenerator.NetworkFlowModel.PrimalSolution, Commodity}","page":"Public interface","title":"FlowGenerator.get_path_to_flow_map","text":"get_path_to_flow_map(\n    problem::NetworkFlowModel.Problem,\n    solution::NetworkFlowModel.PrimalSolution,\n    commodity::Commodity,\n)\n\nReturn the path to flow map for a specific commodity in the given solution.\n\n\n\n\n\n","category":"method"},{"location":"#FlowGenerator.get_problem-Tuple{FlowGenerator.NetworkFlowProblemBuilder}","page":"Public interface","title":"FlowGenerator.get_problem","text":"get_problem(builder::NetworkFlowProblemBuilder)\n\nCreate a NetworkFlowModel.Problem based on the data given in NetworkFlowProblemBuilder.\n\n\n\n\n\n","category":"method"},{"location":"#FlowGenerator.new_arc!-Tuple{FlowGenerator.NetworkFlowProblemBuilder, Dict{Vertex, Float64}, Vertex}","page":"Public interface","title":"FlowGenerator.new_arc!","text":"new_arc!(\n    builder::NetworkFlowProblemBuilder,\n    tail_to_multiplier_map::Dict{Vertex,Float64},\n    head::Vertex;\n    cost::Float64 = 0.0,\n    capacity::Float64 = Inf,\n    var_type::VarType = CONTINUOUS,\n)\n\nCreate a new (hyper-)arc in the network flow problem builder.\n\nNote: VarType can be either CONTINUOUS or INTEGER\n\n\n\n\n\n","category":"method"},{"location":"#FlowGenerator.new_arc!-Tuple{FlowGenerator.NetworkFlowProblemBuilder, Tuple{Vertex, Float64}, Vertex}","page":"Public interface","title":"FlowGenerator.new_arc!","text":"new_arc!(\n    builder::NetworkFlowProblemBuilder,\n    (tail, multiplier)::Tuple{Vertex,Float64},\n    head::Vertex;\n    cost::Float64 = 0.0,\n    capacity::Float64 = Inf,\n    var_type::VarType = CONTINUOUS,\n)\n\nCreate a new arc in the network flow problem builder.\n\nNote: VarType can be either CONTINUOUS or `INTEGER\n\n\n\n\n\n","category":"method"},{"location":"#FlowGenerator.new_arc!-Tuple{FlowGenerator.NetworkFlowProblemBuilder, Vertex, Vertex}","page":"Public interface","title":"FlowGenerator.new_arc!","text":"new_arc!(\n    builder::NetworkFlowProblemBuilder,\n    tail::Vertex,\n    head::Vertex;\n    cost::Float64 = 0.0,\n    capacity::Float64 = Inf,\n    var_type::VarType = CONTINUOUS,\n)\n\nCreate a new arc in the network flow problem builder.\n\nNote: VarType can be either CONTINUOUS or INTEGER\n\n\n\n\n\n","category":"method"},{"location":"#FlowGenerator.new_commodity!-Tuple{FlowGenerator.NetworkFlowProblemBuilder, Vertex, Vertex, Number, Number}","page":"Public interface","title":"FlowGenerator.new_commodity!","text":"new_commodity!(\n    builder::NetworkFlowProblemBuilder,\n    source::Vertex,\n    sink::Vertex,\n    demand::Number,\n    capacity::Number;\n    violation_penalty_cost::Number = 1e3,\n)\n\nAdd a new commodity to the network flow problem builder.\n\n\n\n\n\n","category":"method"},{"location":"#FlowGenerator.new_constraint!-Tuple{FlowGenerator.NetworkFlowProblemBuilder}","page":"Public interface","title":"FlowGenerator.new_constraint!","text":"new_constraint!(\n    builder::NetworkFlowProblemBuilder;\n    lb::Float64 = -Inf,\n    ub::Float64 = Inf,\n    violation_penalty_cost::Float64 = 1e3,\n)\n\nCreate a new linear constraint and add it to the network flow problem builder.\n\nExceptions\n\nArgumentError: If the lower bound is greater than the upper bound, or if the bounds are infeasible or unbounded.\n\n\n\n\n\n","category":"method"},{"location":"#FlowGenerator.new_problem_builder-Tuple{}","page":"Public interface","title":"FlowGenerator.new_problem_builder","text":"new_problem_builder()\n\nCreate a new empty instance of NetworkFlowProblemBuilder.\n\n\n\n\n\n","category":"method"},{"location":"#FlowGenerator.new_vertex!-Tuple{FlowGenerator.NetworkFlowProblemBuilder}","page":"Public interface","title":"FlowGenerator.new_vertex!","text":"new_vertex!(builder::NetworkFlowProblemBuilder)\n\nCreate a new vertex in the network flow problem builder.\n\n\n\n\n\n","category":"method"},{"location":"#FlowGenerator.optimize!-Tuple{FlowGenerator.NetworkFlowModel.Problem, Any}","page":"Public interface","title":"FlowGenerator.optimize!","text":"optimize!(\n    problem::NetworkFlowModel.Problem,\n    mip_solver;\n    initial_paths::Vector{Tuple{Commodity,Path}} = Tuple{Commodity,Path}[],\n    obj_cutoff = Inf,\n)\n\nOptimize the network flow problem using FlowGenerator internal solver based on the specified MIP optimizer.\n\nReturns a PrimalSolution object.\n\n\n\n\n\n","category":"method"},{"location":"#FlowGenerator.optimize!-Tuple{FlowGenerator.NetworkFlowModel.Problem, FlowGenerator.AbstractSolver.AbstractSolverParams}","page":"Public interface","title":"FlowGenerator.optimize!","text":"optimize!(\n    problem::NetworkFlowModel.Problem,\n    params::Parameters.AbstractSolverParams;\n    initial_paths::Vector{Tuple{Commodity,Path}} = Tuple{Commodity,Path}[],\n)\n\nOptimize the network flow problem using the specified solver parameters.\n\nReturns a PrimalSolution object.\n\n\n\n\n\n","category":"method"},{"location":"#FlowGenerator.optimize_by_mip_solver!-Tuple{FlowGenerator.NetworkFlowModel.Problem, Any}","page":"Public interface","title":"FlowGenerator.optimize_by_mip_solver!","text":"optimize_by_mip_solver!(problem::NetworkFlowModel.Problem, mip_solver; time_limit::Float64 = 3600)\n\nOptimize the network flow problem directly by an external MIP solver. Keyword parameter time_limit is given in seconds.\n\nReturns a PrimalSolution object.\n\n\n\n\n\n","category":"method"},{"location":"#FlowGenerator.optimize_linear_relaxation!-Tuple{FlowGenerator.NetworkFlowModel.Problem, Any}","page":"Public interface","title":"FlowGenerator.optimize_linear_relaxation!","text":"optimize_linear_relaxation!(problem::NetworkFlowModel.Problem, mip_solver; use_column_generation::Bool = false)\n\nOptimize the network flow problem while ignoring all variable integrality constraints.\n\n\n\n\n\n","category":"method"},{"location":"#FlowGenerator.set_capacity!-Tuple{FlowGenerator.NetworkFlowProblemBuilder, Arc, Float64}","page":"Public interface","title":"FlowGenerator.set_capacity!","text":"set_capacity!(builder::NetworkFlowProblemBuilder, arc::Arc, capacity::Float64)\n\nSet the capacity of an arc in the network flow problem builder.\n\n\n\n\n\n","category":"method"},{"location":"#FlowGenerator.set_constraint_coefficient!-Tuple{FlowGenerator.NetworkFlowProblemBuilder, FlowGenerator.DoubleBoundedConstraint, Arc, Float64}","page":"Public interface","title":"FlowGenerator.set_constraint_coefficient!","text":"set_constraint_coefficient!(\n    builder::NetworkFlowProblemBuilder,\n    constraint::DoubleBoundedConstraint,\n    arc::Arc,\n    coeff::Float64,\n)\n\nSet the coefficient of an arc in a linear constraint in the network flow problem builder.\n\n\n\n\n\n","category":"method"},{"location":"#FlowGenerator.set_cost!-Tuple{FlowGenerator.NetworkFlowProblemBuilder, Arc, Float64}","page":"Public interface","title":"FlowGenerator.set_cost!","text":"set_cost!(builder::NetworkFlowProblemBuilder, arc::Arc, cost::Float64)\n\nSet the cost of an arc in the network flow problem builder.\n\n\n\n\n\n","category":"method"},{"location":"#FlowGenerator.set_var_type!-Tuple{FlowGenerator.NetworkFlowProblemBuilder, Arc, FlowGenerator.NetworkFlowModel.VarType}","page":"Public interface","title":"FlowGenerator.set_var_type!","text":"set_var_type!(builder::NetworkFlowProblemBuilder, arc::Arc, var_type::VarType)\n\nSet the variable type of an arc in the network flow problem builder.\n\n\n\n\n\n","category":"method"}]
}
